### 流式导出

假如要从数据库导出100万数据，选出一个占用cpu内存低的方法。

流式导入是一个选择

定义:jvm从数据库一批一批数据导入到内存

![Snipaste_2025-04-24_01-37-48](.\img\Snipaste_2025-04-24_01-37-48.jpg)

这里采用mariadb+mybatis的方案去实现，具体实现看代码

最终导入耗时:455576ms



#### 踩坑

报错：java.lang.IllegalStateException: A Cursor is already closed.

原因：Cursor 必须要在事务中使用，保持长链接，否则查完就立马关闭，关闭后想再使用就会报错

使用时注意事务是否有失效情况，当时我就是没注意方法内部调用导致事务失效

以下是事务失效

```
demo(){
	export();
}

@Transactional
export(){

}
```



#### 不选择使用xlsx格式原因

项目中我们导出为csv，不是导出为xlsx，理由是xlsx占用内存大，以poi导出xlsx为例，导出时涉及workbook，sheet，styles，rows....对象，而csv只需使用逗号分隔，整行写入到文件中，占用内存小，效率也会提升很多



#### 流式导出缺点

- mariaDB

  经过测试，mariaDB使用Cursor只能在@Transactional下使用，无论像mysql那样在url加上

  ```
  &useCursorFetch=true&autoReconnect=true&useLocalSessionState=true
  ```

  还是在mapper.xml中加上

  ```
  fetchSize = Integer.MIN_VALUE
  ```

  都没有作用

  100万数据在@Transactional中读取毫无疑问就会造成大事务问题，mariaDB使用的是REPEATABLE READ，为了防止幻读会加上间隙锁，导致锁竞争加剧。长时间持有连接池连接也可能造成连接超时很连接不够用问题

- mysql

  mysql基本跟mariaDB一致，但是可以通过

  ```
  &useCursorFetch=true&autoReconnect=true&useLocalSessionState=true
  ```

  令Cursor不需要在事务中使用，但是这个**配置一定要小心**，useLocalSessionState叫伪事务，开启是由一定风险的

  他让客户段自己检查事务状态，就会导致数据库与程序之间的事务状态不一致，而且允许在无事务的情况下保持连接性，没有事务的隔离，就会容易造成脏读

- oracle

  oracle天生支持游标，不需要做什么配置，不过同样会造成大事务问题，只不过这种情况下，由于oracle使用的是READ COMMITTED，很少会造成锁竞争





#### fetchSize配置

我们在项目中使用  fetchSize = 1000实际上并不是真正的流式获取模式，他只是从数据库一次查1000行放在内存中，可以当成分页查询

配置`fetch_size = Integer.MIN_VALUE`，也就是**fetch_size  = '-2147483648' "**配置上才是真正的流式获取，他每次就获取一行数据，当然这种配置会造成占用连接时间大大增加了，整个导出也会变慢，而我们经过测试，1000条数据也不会很占内存，cpu很快就会回收1000行数据，所以我采用fetchSize = 1000



fetch_size  = '-2147483648'配置时常常也会配置上resultSetType="FORWARD_ONLY"，resultSetType="FORWARD_ONLY"是保证结果集不会反向移动和随机跳转，避免位置遍历，提高效率